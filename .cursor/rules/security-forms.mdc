---
name: security-forms
description: INTELLIGENT: Form and AJAX security patterns - Auto-triggered when AI needs validation methods for $_POST, AJAX endpoints, nonce verification, or input sanitization. FORCE LOADED by ajax-hardening.mdc for complete AJAX security.
globs:
  - Dashboard/**/*.php
  - Dashboard/**/*.js
alwaysApply: false
---

# 🔒 **FORM & AJAX SECURITY PATTERNS - INTELLIGENT FAILSAFE HOOK**

## 🧠 **INTELLIGENT AUTO-TRIGGER CONDITIONS**

**AI ASSISTANT MUST REFERENCE this guide when detecting ANY of these form/AJAX security patterns:**

### **🔍 TRIGGER KEYWORDS & PATTERNS:**
```php
// FORM & AJAX SECURITY TRIGGERS - AI SHOULD LOAD THIS FILE
$_POST                       // Form/AJAX data processing
$_REQUEST                    // Request data handling
$_GET                        // GET parameter processing
wp_ajax_                     // AJAX hook registration
wp_ajax_nopriv_              // Public AJAX hooks
admin-ajax.php               // AJAX endpoint usage
wp_send_json_success         // AJAX response patterns
wp_send_json_error           // AJAX error handling
wp_verify_nonce              // Nonce verification
check_admin_referer          // CSRF protection
current_user_can             // Capability checking
sanitize_text_field          // Input sanitization
sanitize_email               // Email sanitization
wp_nonce_field               // Nonce field generation
Dashboard_Security_Forms     // Security class usage
validate_*_form              // Form validation methods
validate_*_ajax              // AJAX validation methods
"form processing"            // Form handling discussions
"ajax security"              // AJAX security discussions
"nonce verification"         // Security validation discussions
"input sanitization"         // Data cleaning discussions
"capability check"           // Permission validation discussions
```

### **🎯 CONTEXT-BASED TRIGGERS:**
- AJAX endpoint development or modification
- Form processing implementation
- User input validation requirements
- Security validation method creation
- Nonce verification implementation
- Capability checking for administrative functions
- Input sanitization and data cleaning needs

### **📊 INTEGRATION TRIGGERS:**
- References from ajax-hardening.mdc (force loaded)
- Complex security validation scenarios
- Multi-step form processing requirements
- Custom validation method development

---
## 🔍 **Input Validation & Sanitization** (`input_sanitize`)

### **PMPro Comprehensive Input Sanitization Pattern**
**Pattern Source**: PMPro includes/functions.php, preheaders/checkout.php
**Index Terms**: `input_sanitize`, `form_validation`, `comprehensive_sanitization`
**Auto-Trigger**: `$_POST` array processing, `pmpro_setOption` calls

```php
// ✅ GOOD: PMPro comprehensive input sanitization
// Pattern from paid-memberships-pro/includes/functions.php
function pmpro_setOption( $s, $v = null, $sanitize_function = 'sanitize_text_field', $autoload = false ) {
    if ( $v === null && isset( $_POST[ $s ] ) ) {
        // phpcs:disable WordPress.Security.ValidatedSanitizedInput.InputNotSanitized
        if ( is_array( $_POST[ $s ] ) ) {
            $v = array_map( $sanitize_function, $_POST[ $s ] );
        } else {
            $v = call_user_func( $sanitize_function, $_POST[ $s ] );
        }
        // phpcs:enable WordPress.Security.ValidatedSanitizedInput.InputNotSanitized
    }

    if ( is_array( $v ) ) {
        $v = implode( ',', $v );
    } elseif ( is_string( $v ) ) {
        $v = trim( $v );
    }

    return update_option( 'pmpro_' . $s, $v, $autoload );
}
```

### **PMPro Checkout Field Sanitization Pattern**
**Pattern Source**: PMPro preheaders/checkout.php
**Index Terms**: `input_sanitize`, `checkout_fields`, `email_validation`
**Auto-Trigger**: Email fields, phone fields, checkout processing

```php
// ✅ GOOD: PMPro checkout field sanitization
// Pattern from paid-memberships-pro/preheaders/checkout.php
if ( isset( $_REQUEST['bphone'] ) ) {
    $bphone = stripslashes( sanitize_text_field( $_REQUEST['bphone'] ) );
} else {
    $bphone = "";
}
if ( isset ( $_REQUEST['bemail'] ) ) {
    $bemail = stripslashes( sanitize_email( $_REQUEST['bemail'] ) );
} elseif ( is_user_logged_in() ) {
    $bemail = $current_user->user_email;
} else {
    $bemail = "";
}
if ( isset( $_REQUEST['bconfirmemail_copy'] ) ) {
    $bconfirmemail = $bemail;
} elseif ( isset( $_REQUEST['bconfirmemail'] ) ) {
    $bconfirmemail = stripslashes( sanitize_email( $_REQUEST['bconfirmemail'] ) );
} elseif ( is_user_logged_in() ) {
    $bconfirmemail = $current_user->user_email;
} else {
    $bconfirmemail = "";
}

// Credit card fields
if ( isset( $_REQUEST['CardType'] ) && ! empty( $_REQUEST['AccountNumber'] ) ) {
    $CardType = sanitize_text_field( $_REQUEST['CardType'] );
} else {
    $CardType = "";
}
if ( isset( $_REQUEST['AccountNumber'] ) ) {
    $AccountNumber = sanitize_text_field( $_REQUEST['AccountNumber'] );
} else {
    $AccountNumber = "";
}
```

### **PMPro Advanced Sanitization Pattern**
**Pattern Source**: PMPro classes/class-pmpro-field.php
**Index Terms**: `input_sanitize`, `field_validation`, `conditional_sanitization`
**Auto-Trigger**: Field objects, dynamic form processing

```php
// ✅ GOOD: PMPro advanced field sanitization
// Pattern from paid-memberships-pro/classes/class-pmpro-field.php
function get_value_from_request() {
    if ( isset( $_REQUEST[ $this->name ] ) ) {
        $value = $_REQUEST[$this->name]; // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized
    } elseif ( isset( $_REQUEST[ $this->name . '_checkbox' ] ) && $this->type == 'checkbox' ) {
        // Empty checkbox.
        $value = 0;
    } elseif ( ! empty( $_REQUEST[ $this->name . '_checkbox' ] ) && in_array( $this->type, array( 'checkbox_grouped', 'select2' ) ) )    {
        // Empty group checkboxes or select2.
        $value = array();
    } elseif ( isset( $_FILES[$this->name] ) && $this->type == 'file' ) {
        // File field.
        $value = $_FILES[$this->name]['name']; // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized
    }  elseif ( isset( $_SESSION[$this->name] ) ) {
        // Value stored in session.
        if ( is_array( $_SESSION[$this->name] ) && isset( $_SESSION[$this->name]['name'] ) ) {
            // File field in session.
            $_FILES[$this->name] = $_SESSION[$this->name]; // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized
            $value = $_SESSION[$this->name]['name']; // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized
        } else {
            // Other field in session.
            $value = $_SESSION[$this->name]; // phpcs:ignore WordPress.Security.ValidatedSanitizedInput.InputNotSanitized
        }

        // Clean up session.
        unset($_SESSION[$this->name]);
    } else {
        // No value found.
        return null;
    }

    // Sanitize the value if needed.
    if ( ! empty( $field->sanitize ) ) {
        if ( $this->type == 'textarea' ) {
            $value = sanitize_textarea_field( $value );
        } elseif ( is_array( $value ) ) {
            $value = array_map( 'sanitize_text_field', $value );
        } else {
            $value = sanitize_text_field( $value );
        }
    }

    return $value;
}
```

### **WP Defender Data Sanitization Pattern**
**Pattern Source**: WP Defender src/functions.php
**Index Terms**: `input_sanitize`, `recursive_sanitization`, `data_validation`
**Auto-Trigger**: Recursive array processing, complex data structures

```php
// ✅ GOOD: WP Defender recursive data sanitization
// Pattern from wp-defender/src/functions.php
function defender_sanitize_data( $data ) {
    foreach ( $data as $key => &$value ) {
        if ( is_array( $value ) ) {
            $value = defender_sanitize_data( $value );
        } else {
            $value = sanitize_textarea_field( $value );
        }
    }

    return $data;
}

// Advanced request data handling with nonce verification
function defender_get_data_from_request(
    ?string $key,
    string $source,
    string $nonce_key = '',
    string $nonce_action = ''
) {
    if ( in_array( $source, array( 'r', 'p', 'g' ), true ) ) {
        if (
            ! empty( $nonce_key ) && ! wp_verify_nonce(
                sanitize_text_field( wp_unslash( $_REQUEST[ $nonce_key ] ?? '' ) ),
                $nonce_action
            )
        ) {
            return null;
        }
    }
    
    // Handle different data sources
    switch ( $source ) {
        case 'r':
            $data = $_REQUEST;
            break;
        case 'p':
            $data = $_POST;
            break;
        case 'g':
            $data = $_GET;
            break;
        case 's':
            $data = $_SERVER;
            break;
        case 'f':
            $data = $_FILES;
            break;
        default:
            $data = array();
            break;
    }

    if ( empty( $key ) ) {
        return $data;
    } elseif ( 's' === $source ) {
        return sanitize_text_field( wp_unslash( $data[ $key ] ?? '' ) );
    } elseif ( 'f' === $source && 'file' === $key && isset( $data[ $key ] ) ) {
        if ( ! empty( $data[ $key ]['name'] ) ) {
            $data[ $key ]['name'] = sanitize_file_name( $data[ $key ]['name'] );
        }
        return $data[ $key ];
    }

    return sanitize_text_field( wp_unslash( $data[ $key ] ?? '' ) );
}
```

### **WP Defender Request Component Pattern**
**Pattern Source**: WP Defender framework/component/class-request.php
**Index Terms**: `input_sanitize`, `request_filtering`, `type_casting`
**Auto-Trigger**: Request object processing, data filtering

```php
// ✅ GOOD: WP Defender request component with filtering
// Pattern from wp-defender/framework/component/class-request.php
public function get_data( $filters = array() ) {
    if ( empty( $filters ) ) {
        return $this->data;
    }
    $data = array();
    foreach ( $filters as $key => $rule ) {
        if ( ! isset( $this->data[ $key ] ) ) {
            continue; // Moving on.
        }
        // Mandatory.
        $type     = $rule['type'];
        $sanitize = $rule['sanitize'] ?? null;

        $value = $this->data[ $key ];
        // Cast.
        settype( $value, $type );
        if ( ! is_array( $sanitize ) ) {
            $sanitize = array( $sanitize );
        }
        foreach ( $sanitize as $function ) {
            if ( null !== $function && function_exists( $function ) ) {
                if ( is_array( $value ) ) {
                    $value = $this->sanitize_array( $value, $function );
                } else {
                    $value = $function( $value );
                }
            }
        }
        $data[ $key ] = $value;
    }

    return $data;
}

// Recursive array sanitization
protected function sanitize_array( $arr, $sanitize ) {
    foreach ( $arr as &$value ) {
        if ( is_array( $value ) ) {
            $value = $this->sanitize_array( $value, $sanitize );
        } else {
            $value = $sanitize( $value );
        }
    }

    return $arr;
}
```

### **PMPro File Upload Validation Pattern**
**Pattern Source**: PMPro includes/functions.php
**Index Terms**: `input_sanitize`, `file_upload`, `mime_validation`
**Auto-Trigger**: `$_FILES` usage, file upload processing

```php
// ✅ GOOD: PMPro file upload validation
// Pattern from paid-memberships-pro/includes/functions.php
function pmpro_check_upload( $file_index ) {
    // Check if the file was uploaded.
    if ( empty( $_FILES[ $file_index ] ) ) {
        return new WP_Error( 'pmpro_upload_error', __( 'No file was uploaded.', 'paid-memberships-pro' ) );
    }

    // Get the file info.
    $file = array_map( 'sanitize_text_field', $_FILES[ $file_index ] );
    if ( empty( $file['name'] ) ) {
        return new WP_Error( 'pmpro_upload_error', __( 'No file name found.', 'paid-memberships-pro' ) );
    }

    // If the current user cannot does not have the unfiltered_upload permission, check if the file is an allowed file type.
    if ( ! current_user_can( 'unfiltered_upload' ) ) {
        $filetype = wp_check_filetype_and_ext( $file['tmp_name'], $file['name'] );
        if ( empty( $filetype['ext'] ) || empty( $filetype['type'] ) ) {
            return new WP_Error( 'pmpro_upload_error', __( 'Invalid file type.', 'paid-memberships-pro' ) );
        }
    }

    // If this is an upload for a user field, we need to perform additional checks.
    $field = PMPro_Field_Group::get_field( $file_index );
    if ( ! empty( $field) ) {
        // First, make sure that this is a 'file' field.
        if ( $field->type !== 'file' ) {
            return new WP_Error( 'pmpro_upload_error', __( 'Invalid field input.', 'paid-memberships-pro' ) );
        }

        // Check the file type against the allowed types.
        $allowed_mime_types = ! empty( $field->allowed_file_types ) ? array_map( 'sanitize_text_field', explode( ',', $field->allowed_file_types ) ) : array();

        //Remove fullstops from the beginning of the allowed file types.
        $allowed_mime_types = array_map( function( $type ) {
            return ltrim( $type, '.' );
        }, $allowed_mime_types );

        // Check the file type against the allowed types. If empty allowed mimes, assume any file upload is okay.
        if ( ! empty( $allowed_mime_types ) && ! in_array( $filetype['ext'], $allowed_mime_types ) ) {
            return new WP_Error( 'pmpro_upload_file_type_error', sprintf( esc_html__( 'Invalid file type. Please try uploading the file type(s): %s', 'paid-memberships-pro' ), implode( ',' ,$allowed_mime_types ) ) );
        }
        
        // Check if the file upload is too big to upload.
        if ( $field->max_file_size > 0 ) {
            $upload_max_file_size_in_bytes = $field->max_file_size * 1024 * 1024;
            if ( $file['size'] > $upload_max_file_size_in_bytes ) {
                return new WP_Error( 'pmpro_upload_file_size_error', sprintf( esc_html__( 'File size is too large for %s. Please upload files smaller than %dMB.', 'paid-memberships-pro' ), $field->label, $field->max_file_size ) );
            }
        }
    }

    return true;
}
```

### **PMPro Safelist Validation Pattern**
**Pattern Source**: PMPro includes/functions.php
**Index Terms**: `input_sanitize`, `safelist_validation`, `whitelist_check`
**Auto-Trigger**: Dropdown validation, option checking

```php
// ✅ GOOD: PMPro safelist validation
// Pattern from paid-memberships-pro/includes/functions.php
function pmpro_sanitize_with_safelist( $needle, $safelist ) {
    if ( ! in_array( $needle, $safelist ) ) {
        return false;
    } else {
        return $needle;
    }
}

// Generic sanitization function
function pmpro_sanitize( $value, $field = null ) {
    if ( is_array( $value ) ) {
        foreach ( $value as $key => $val ) {
            $value[ $key ] = pmpro_sanitize( $val );
        }
    }

    if ( is_object( $value ) ) {
        foreach ( $value as $key => $val ) {
            $value->{$key} = pmpro_sanitize( $val );
        }
    }

    if ( ! empty( $field ) && ! empty( $field->type ) && $field->type === 'textarea' ) {
        $value = sanitize_textarea_field( $value );
    } elseif ( ( ! is_array( $value ) ) && ctype_alpha( $value ) ||
         ( ( ! is_array( $value ) ) && strtotime( $value ) ) ||
         ( ( ! is_array( $value ) ) && is_string( $value ) ) ||
         ( ( ! is_array( $value ) ) && is_numeric( $value) )
    ) {
        $value = sanitize_text_field( $value );
    }

    return $value;
}
```

---

## 🎯 **Dashboard Plugin Form Security Integration**

### **Auto-Trigger Integration Patterns**
```php
/**
 * DASHBOARD PLUGIN AUTO-INTEGRATION:
 * 
 * When AI detects form patterns in Dashboard Plugin files:
 * 1. Auto-branch to Dashboard/security/security-forms.php
 * 2. Read relevant patterns from form-security.mdc
 * 3. Implement class-specific security method
 * 4. Return to original development context
 * 
 * ISOLATION STRATEGY:
 * Each Dashboard Plugin class gets isolated security methods:
 * - validate_menu_manager_form()
 * - validate_template_manager_form()
 * - validate_permission_manager_form()
 * - validate_admin_menu_form()
 */
```

### **Form Security Implementation Checklist**
**MANDATORY for all form processing:**

#### **🔒 Nonce Protection** - REQUIRED FOR ALL FORMS
- [ ] **Admin Forms**: check_admin_referer() verification
- [ ] **AJAX Forms**: wp_verify_nonce() with route checking
- [ ] **Multi-Action Forms**: Dynamic nonce verification per action
- [ ] **Checkout Forms**: Version-aware nonce validation

#### **🔍 Input Sanitization** - REQUIRED FOR ALL INPUT
- [ ] **Text Fields**: sanitize_text_field() for all text inputs
- [ ] **Email Fields**: sanitize_email() with validation
- [ ] **Array Data**: Recursive sanitization with array_map()
- [ ] **File Uploads**: MIME type validation and size checking

#### **🛡️ CSRF Protection** - REQUIRED FOR ALL SUBMISSIONS
- [ ] **Request Validation**: Proper $_POST/$_GET handling
- [ ] **Origin Checking**: Referrer validation where applicable
- [ ] **Action Verification**: Multi-action form protection
- [ ] **Session Security**: Proper session token handling

---

**Document Version**: 1.0.0 - Form Security Patterns  
**Last Updated**: July 18, 2025  
**Pattern Sources**: PMPro v3.4.7, WP Defender v5.3.1  
**AI Auto-Trigger**: Enabled with mandatory pattern detection  
**Dashboard Integration**: Optimized for class-specific isolation
description:
globs:
alwaysApply: false
---
